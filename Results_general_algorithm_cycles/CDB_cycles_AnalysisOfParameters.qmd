---
title: "CDB_cycles_AnalysisOfParameters"
editor: visual
format: gfm
always_allow_html: true
---

In this notebook, we are studying the different parameters of our method Complexity Driven Bagging so as to offer a range of selection to the final user. In particular, we have three parameters:

-   Split: the number of splits in which we cut the complexity spectrum. s=1 implies we are training with one easy sample, one uniform sample and one hard sample. That is, the cycle length is 3. s=2 implies 6 samples of different complexity (cycle length is 6).

-   Alpha: to give more weight to the easiest and the hardest instances in the bootstrap sampling procedure with the aim of training the classifier with samples of higher or lower complexity (thus, enlarging the original range of complexity).

-   Number of cycles. How many times the procedure is repeated. This is totally related with the final number of ensembles.

Besides this 3 parameters, we have obtained results for different complexity measures. For the analysis of the parameters, we have aggregated results over the different complexity measures.

First, we are studying the recommended number of cycles. That is, given a value of split and a value of alpha, we want to know when the best accuracy is obtained, when there are significant differences, etc. so as to recommend the lower number of cycles (lower number of ensembles) with the best performance.

Once the number of cycles is reduced, we perform a similar analysis on the alpha parameter and the on the split parameter.

# First view

```{r}
library(tidyverse)
library(ggpubr)
library(rstatix)
library(datarium)
library(DT)
library(ggplot2)
library(patchwork)

getwd()
setwd("/home/carmen/PycharmProjects/EnsemblesComplexity/Results_general_algorithm_cycles")
#datos <- read.csv('TotalAggregatedResults_ParameterConfiguration_CDB.csv') 
# Data aggregated over complexity measures
datos <- read.csv('df_summary_data.csv') 
str(datos)
# Convert id and time into factor variables
datos <- datos %>%
  convert_as_factor(Dataset, combo_alpha_split, n_cycle,n_ensemble)
```

### Mean, median and standard deviation of accuracy for all levels of split

```{r warning=FALSE}
table_split <- datos %>%
  group_by(split) %>%
  summarise_at(vars(accuracy_mean_mean),  list(mean = mean, median = median, std = sd))
knitr::kable(table_split)
```

```{r echo=FALSE, warning=FALSE}

# Convertir el dataframe al formato largo para ggplot
df_long <- tidyr::pivot_longer(table_split, cols = c("mean", "median", "std"), 
                               names_to = "variable", values_to = "value")

df_long$split <- as.numeric(df_long$split)

# Crear el primer gráfico (mean y median) con ajuste en los breaks del eje x
g1 <- ggplot(df_long[df_long$variable %in% c("mean", "median"),], 
             aes(x = split, y = value, color = variable)) +
  geom_line(size = 1) +
  geom_point(size = 1) +
  labs(title = "Evolution mean median",
       x = "split", y = "Value", color = " ") +
  theme_minimal() +
  scale_color_manual(values = c("mean" = "purple", "median" = "orange"))

# Crear el segundo gráfico (std) con ajuste en los breaks del eje x
g2 <- ggplot(df_long[df_long$variable == "std",], 
             aes(x = split, y = value, color = variable)) +
  geom_line(size = 1) +
  geom_point(size = 1) +
  labs(title = "Evolution std",
       x = "split", y = "Value", color = " ") +
  theme_minimal() +
  scale_color_manual(values = c("std" = "blue"))

# Colocar los dos gráficos juntos con patchwork
g1 + g2 + plot_layout(nrow = 2)

```

The higher the value of split, the higher the mean (with some exceptions) of accuracy, the lower the median and the lower the standard deviation. ¿Medium-low split values?

### Mean, median and standard deviation of accuracy for all levels of alpha

```{r warning=FALSE}
table_alpha <- datos %>%
  group_by(alpha) %>%
  summarise_at(vars(accuracy_mean_mean),  list(mean = mean, median = median, std = sd))
knitr::kable(table_alpha)
```

```{r echo=FALSE, warning=FALSE}

# Convertir el dataframe al formato largo para ggplot
df_long <- tidyr::pivot_longer(table_alpha, cols = c("mean", "median", "std"), 
                               names_to = "variable", values_to = "value")

df_long$alpha <- as.numeric(df_long$alpha)

# Crear el primer gráfico (mean y median) con ajuste en los breaks del eje x
g1 <- ggplot(df_long[df_long$variable %in% c("mean", "median"),], 
             aes(x = alpha, y = value, color = variable)) +
  geom_line(size = 1) +
  geom_point(size = 1) +
  labs(title = "Evolution mean median",
       x = "alpha", y = "Value", color = " ") +
  theme_minimal() +
  scale_color_manual(values = c("mean" = "purple", "median" = "orange"))

# Crear el segundo gráfico (std) con ajuste en los breaks del eje x
g2 <- ggplot(df_long[df_long$variable == "std",], 
             aes(x = alpha, y = value, color = variable)) +
  geom_line(size = 1) +
  geom_point(size = 1) +
  labs(title = "Evolution std",
       x = "alpha", y = "Value", color = " ") +
  theme_minimal() +
  scale_color_manual(values = c("std" = "blue"))

# Colocar los dos gráficos juntos con patchwork
g1 + g2 + plot_layout(nrow = 2)
```

The higher the value of alpha, the lower the mean and the median of accuracy. The standard deviation keeps lower for low-medium values. --\> Low-medium values of alpha. Lower than 12.

### Mean, median and standard deviation of accuracy for all levels of n_cycles (for some split values)

We cannot perform a summary of 'n_cycle' in general because the number of cycles depends on the value of split. Thus, we show some cases.

**split = 1**

```{r warning=FALSE}
table_split1 <- datos %>% filter(split == 1) %>%
  group_by(n_cycle) %>%
  summarise_at(vars(accuracy_mean_mean),  list(mean = mean, median = median, std = sd))
knitr::kable(table_split1)

#datatable(table_split1)
```

```{r echo=FALSE, warning=FALSE}

# Convertir el dataframe al formato largo para ggplot
df_long <- tidyr::pivot_longer(table_split1, cols = c("mean", "median", "std"), 
                               names_to = "variable", values_to = "value")

df_long$n_cycle <- as.numeric(df_long$n_cycle)

# Crear el primer gráfico (mean y median) con ajuste en los breaks del eje x
g1 <- ggplot(df_long[df_long$variable %in% c("mean", "median"),], 
             aes(x = n_cycle, y = value, color = variable)) +
  geom_line(size = 1) +
  geom_point(size = 1) +
  labs(title = "Evolution mean median",
       x = "n_cycle", y = "Value", color = " ") +
  theme_minimal() +
  scale_color_manual(values = c("mean" = "purple", "median" = "orange"))

# Crear el segundo gráfico (std) con ajuste en los breaks del eje x
g2 <- ggplot(df_long[df_long$variable == "std",], 
             aes(x = n_cycle, y = value, color = variable)) +
  geom_line(size = 1) +
  geom_point(size = 1) +
  labs(title = "Evolution std",
       x = "n_cycle", y = "Value", color = " ") +
  theme_minimal() +
  scale_color_manual(values = c("std" = "blue"))

# Colocar los dos gráficos juntos con patchwork
g1 + g2 + plot_layout(nrow = 2)

```

The higher the number of cycles, the higher the mean, median of accuracy and the lower the standard deviation. However, for high values of cycles, the accuracy clearly stabilizes and there is no

**split = 2**

```{r warning=FALSE}
table_split2 <- datos %>% filter(split == 2) %>%
  group_by(n_cycle) %>%
  summarise_at(vars(accuracy_mean_mean),  list(mean = mean, median = median, std = sd))
knitr::kable(table_split2)
```

```{r echo=FALSE, warning=FALSE}
# Convertir el dataframe al formato largo para ggplot
df_long <- tidyr::pivot_longer(table_split2, cols = c("mean", "median", "std"), 
                               names_to = "variable", values_to = "value")

df_long$n_cycle <- as.numeric(df_long$n_cycle)

# Crear el primer gráfico (mean y median) con ajuste en los breaks del eje x
g1 <- ggplot(df_long[df_long$variable %in% c("mean", "median"),], 
             aes(x = n_cycle, y = value, color = variable)) +
  geom_line(size = 1) +
  geom_point(size = 1) +
  labs(title = "Evolution mean median",
       x = "n_cycle", y = "Value", color = " ") +
  theme_minimal() +
  scale_color_manual(values = c("mean" = "purple", "median" = "orange"))

# Crear el segundo gráfico (std) con ajuste en los breaks del eje x
g2 <- ggplot(df_long[df_long$variable == "std",], 
             aes(x = n_cycle, y = value, color = variable)) +
  geom_line(size = 1) +
  geom_point(size = 1) +
  labs(title = "Evolution std",
       x = "n_cycle", y = "Value", color = " ") +
  theme_minimal() +
  scale_color_manual(values = c("std" = "blue"))

# Colocar los dos gráficos juntos con patchwork
g1 + g2 + plot_layout(nrow = 2)

```

**split = 4**

```{r warning=FALSE}
table_split4 <- datos %>% filter(split == 4) %>%
  group_by(n_cycle) %>%
  summarise_at(vars(accuracy_mean_mean),  list(mean = mean, median = median, std = sd))
knitr::kable(table_split4)
```

```{r echo=FALSE, warning=FALSE}
# Convertir el dataframe al formato largo para ggplot
df_long <- tidyr::pivot_longer(table_split4, cols = c("mean", "median", "std"), 
                               names_to = "variable", values_to = "value")

df_long$n_cycle <- as.numeric(df_long$n_cycle)

# Crear el primer gráfico (mean y median) con ajuste en los breaks del eje x
g1 <- ggplot(df_long[df_long$variable %in% c("mean", "median"),], 
             aes(x = n_cycle, y = value, color = variable)) +
  geom_line(size = 1) +
  geom_point(size = 1) +
  labs(title = "Evolution mean median",
       x = "n_cycle", y = "Value", color = " ") +
  theme_minimal() +
  scale_color_manual(values = c("mean" = "purple", "median" = "orange"))

# Crear el segundo gráfico (std) con ajuste en los breaks del eje x
g2 <- ggplot(df_long[df_long$variable == "std",], 
             aes(x = n_cycle, y = value, color = variable)) +
  geom_line(size = 1) +
  geom_point(size = 1) +
  labs(title = "Evolution std",
       x = "n_cycle", y = "Value", color = " ") +
  theme_minimal() +
  scale_color_manual(values = c("std" = "blue"))

# Colocar los dos gráficos juntos con patchwork
g1 + g2 + plot_layout(nrow = 2)

```

**split = 10**

```{r warning=FALSE}
table_split10 <- datos %>% filter(split == 10) %>%
  group_by(n_cycle) %>%
  summarise_at(vars(accuracy_mean_mean),  list(mean = mean, median = median, std = sd))
knitr::kable(table_split10)
```

```{r echo=FALSE, warning=FALSE}
# Convertir el dataframe al formato largo para ggplot
df_long <- tidyr::pivot_longer(table_split10, cols = c("mean", "median", "std"), 
                               names_to = "variable", values_to = "value")

df_long$n_cycle <- as.numeric(df_long$n_cycle)

# Crear el primer gráfico (mean y median) con ajuste en los breaks del eje x
g1 <- ggplot(df_long[df_long$variable %in% c("mean", "median"),], 
             aes(x = n_cycle, y = value, color = variable)) +
  geom_line(size = 1) +
  geom_point(size = 1) +
  labs(title = "Evolution mean median",
       x = "n_cycle", y = "Value", color = " ") +
  theme_minimal() +
  scale_color_manual(values = c("mean" = "purple", "median" = "orange"))

# Crear el segundo gráfico (std) con ajuste en los breaks del eje x
g2 <- ggplot(df_long[df_long$variable == "std",], 
             aes(x = n_cycle, y = value, color = variable)) +
  geom_line(size = 1) +
  geom_point(size = 1) +
  labs(title = "Evolution std",
       x = "n_cycle", y = "Value", color = " ") +
  theme_minimal() +
  scale_color_manual(values = c("std" = "blue"))

# Colocar los dos gráficos juntos con patchwork
g1 + g2 + plot_layout(nrow = 2)

```

# Number of cycles

```{r warning=FALSE}
# Tenemos que hacer el análisis para cada combo_alpha_split
valores_combo = levels(datos$combo_alpha_split)
n_combo = length(valores_combo)
combo_friedman = data.frame(valores_combo)
combo_friedman$p_value = rep(NA,n_combo)

for (i in valores_combo){
  #print(i)
  datos_i = datos[datos$combo_alpha_split==i,]
  fri = friedman.test(accuracy_mean_mean ~ n_cycle |Dataset, data=as.matrix(datos_i))
  combo_friedman[combo_friedman$valores_combo==i,2] = fri$p.value
}
combo_friedman[combo_friedman$p_value> 0.05]
# es decir, en todos los casos hay diferencias significativas
```

Una vez hemos visto que existen diferencias significativas entre al menos un valor del combo hacemos las comparaciones múltiples

```{r warning=FALSE}

dif_no_sig <- data.frame(valores_combo)
dif_no_sig$niveles = rep(NA,n_combo)

# Lo dejamos en comentarios porque tarda mucho

# for (i in valores_combo){
#   print(i)
#   datos_i = datos[datos$combo_alpha_split==i,]
#   datos_i$n_cycle <- factor(datos_i$n_cycle) # los niveles del factor cambian en cada subset
#   pwc2 <- datos_i %>% 
#     wilcox_test(accuracy_mean_mean ~ n_cycle, paired = TRUE, p.adjust.method = "bonferroni")
#   # Filtrar comparaciones con diferencias no significativas (suponiendo un umbral de p > 0.05)
#   no_significativas <- pwc2[pwc2$p.adj>0.1,]
# 
#   
#   # si no todas las comparaciones con ese nivel son no significativas, lo quitamos 
#   # es decir, no nos vale que solo no haya diferencia entre 3 y 5 y con el resto (3-6,3-7,etc) sí
#   max_cycles = max(as.numeric(pwc2$group2))
#   valores_check <- unique(as.numeric(no_significativas$group1))
#   for (v in valores_check){
#     if (sum(no_significativas$group1 == v) <(max_cycles - v) ){
#       no_significativas = no_significativas[no_significativas$group1!=v,]
#     }
#   }
#   
#   # Extraer los niveles de los pares con diferencias no significativas
#   niveles_no_significativos <- unique(c(no_significativas$group1, no_significativas$group2))
# 
#   dif_no_sig[dif_no_sig$valores_combo==i,2] = paste(niveles_no_significativos, collapse = ", ")
# }

#write.csv(dif_no_sig, "CDB_cycles_ParametersComboAlphaSplit_dif_no_signif_cycles_mean.csv")
```

```{r warning=FALSE}
dif_no_sig_mean <- read.csv('CDB_cycles_ParametersComboAlphaSplit_dif_no_signif_cycles_mean.csv') 
print(dif_no_sig_mean)
```

AHORA AQUÍ TENGO QUE RESUMIR A PARTIR DE CUANDO NO HAY DIFERENCIAS SIGNIFICATIVAS PARA CADA CASO Y RELACIONARLO CON EL NÚMERO DE ENSEMBLES

LUEGO HACER LO MISMO PARA STD Y CON ELLO FILTRAR N_CYCLES
